/**
 * @file lopcodes.h
 * @brief Lua虚拟机操作码定义：虚拟机指令集架构的核心定义文件
 * 
 * 详细说明：
 * 这个文件定义了Lua虚拟机的完整指令集架构，包括所有操作码、指令格式、
 * 参数编码方式和操作宏。Lua虚拟机是一个基于寄存器的虚拟机，与传统的
 * 基于栈的虚拟机不同，它使用寄存器来存储临时值，这种设计可以减少指令
 * 数量并提高执行效率。
 * 
 * 系统架构定位：
 * - 虚拟机指令集定义：定义了Lua虚拟机执行引擎的指令集
 * - 编译器后端接口：为Lua编译器提供目标指令格式
 * - 解释器执行核心：为Lua解释器提供指令解析和执行的基础
 * 
 * 技术特点：
 * - 基于寄存器的虚拟机架构，提供高效的指令执行
 * - 32位固定长度指令格式，便于解析和执行
 * - 灵活的参数编码方式，支持多种操作数类型
 * - 完整的操作码集合，涵盖数据操作、控制流、函数调用等
 * 
 * 指令格式设计：
 * Lua虚拟机使用32位固定长度指令，包含以下字段：
 * - 操作码(OP)：6位，定义指令类型
 * - A参数：8位，通常是目标寄存器
 * - B参数：9位，源操作数或跳转偏移
 * - C参数：9位，源操作数或立即数
 * - Bx参数：18位，B和C合并的扩展参数
 * - sBx参数：18位有符号参数，用于跳转偏移
 * 
 * 虚拟机设计原理：
 * Lua虚拟机采用基于寄存器的设计，相比基于栈的虚拟机有以下优势：
 * - 减少指令数量：寄存器可以直接访问，减少了压栈/出栈操作
 * - 提高执行效率：减少了内存访问次数，提高了执行速度
 * - 简化编译器：编译器可以更容易地进行寄存器分配优化
 * 
 * @author Roberto Ierusalimschy (Lua原作者)
 * @version Lua 5.1.5
 * @date 2007
 * @since Lua 5.0
 * @see lua.h, lvm.h, lparser.h
 */

#ifndef lopcodes_h
#define lopcodes_h

#include "llimits.h"

/**
 * @brief 指令格式枚举：定义Lua虚拟机的三种基本指令格式
 * 
 * 详细说明：
 * Lua虚拟机使用三种不同的指令格式来适应不同类型的操作需求。
 * 每种格式都针对特定的操作模式进行了优化，确保指令编码的高效性。
 * 
 * 格式详解：
 * - iABC: 最常用的三操作数格式，适用于大多数运算和数据操作
 * - iABx: 扩展格式，适用于需要大范围操作数的指令（如常量加载）
 * - iAsBx: 有符号扩展格式，主要用于跳转指令和循环控制
 * 
 * 设计考虑：
 * - 指令密度：在32位限制下最大化指令表达能力
 * - 解码效率：简单的位操作即可提取参数
 * - 操作灵活性：支持寄存器、常量、跳转等多种操作模式
 * 
 * @since Lua 5.0
 * @see GET_OPCODE(), GETARG_A(), GETARG_B(), GETARG_C()
 */
enum OpMode {
    iABC,       /**< A(8位) + B(9位) + C(9位) 格式：标准三操作数指令 */
    iABx,       /**< A(8位) + Bx(18位) 格式：扩展操作数指令 */
    iAsBx       /**< A(8位) + sBx(18位) 格式：有符号扩展指令，用于跳转 */
};

/**
 * @name 指令字段大小定义
 * @brief 定义Lua虚拟机指令各个字段的位宽
 * 
 * 详细说明：
 * 这些宏定义了32位指令格式中各个字段的位宽。Lua虚拟机的指令设计
 * 必须在有限的32位空间内合理分配各个字段，以支持足够的操作码数量
 * 和操作数范围。
 * 
 * 位宽分配原理：
 * - 操作码(6位)：支持64种基本操作，足够覆盖Lua的所有操作需求
 * - A参数(8位)：支持256个寄存器，满足大多数函数的局部变量需求
 * - B/C参数(9位)：支持512个操作数，平衡了寄存器和常量的访问范围
 * - Bx参数(18位)：支持262144个常量，满足大型程序的常量表需求
 * 
 * 性能影响：
 * - 较小的寄存器空间减少了内存占用
 * - 固定位宽简化了指令解码逻辑
 * - 合理的字段分配平衡了指令密度和表达能力
 * 
 * @{
 */
#define SIZE_C      9       /**< C字段位宽：支持512个操作数 */
#define SIZE_B      9       /**< B字段位宽：支持512个操作数 */
#define SIZE_Bx     (SIZE_C + SIZE_B)   /**< Bx字段位宽：B和C合并为18位 */
#define SIZE_A      8       /**< A字段位宽：支持256个寄存器 */
#define SIZE_OP     6       /**< 操作码位宽：支持64种操作 */
/** @} */

/**
 * @name 指令字段位置定义
 * @brief 定义Lua虚拟机指令各个字段在32位指令中的位置
 * 
 * 详细说明：
 * 这些宏定义了指令各个字段在32位整数中的起始位置。Lua虚拟机
 * 使用小端序布局，操作码位于最低位，便于快速提取和分派。
 * 
 * 布局设计：
 * ```
 * 31    23    14     8     0
 * |  B  |  C  |  A  | OP  |  (iABC格式)
 * |     Bx    |  A  | OP  |  (iABx格式)
 * |    sBx    |  A  | OP  |  (iAsBx格式)
 * ```
 * 
 * 设计优势：
 * - 操作码在最低位，便于快速分派
 * - A参数位置固定，简化目标寄存器提取
 * - B/C参数位置对称，便于双操作数指令处理
 * 
 * @{
 */
#define POS_OP      0       /**< 操作码起始位置：位0-5 */
#define POS_A       (POS_OP + SIZE_OP)    /**< A字段起始位置：位6-13 */
#define POS_C       (POS_A + SIZE_A)      /**< C字段起始位置：位14-22 */
#define POS_B       (POS_C + SIZE_C)      /**< B字段起始位置：位23-31 */
#define POS_Bx      POS_C   /**< Bx字段起始位置：与C字段相同，位14-31 */
/** @} */

/**
 * @name 指令参数范围限制
 * @brief 定义各个指令字段的最大值和有效范围
 * 
 * 详细说明：
 * 这些宏定义了指令各个字段的最大有效值。由于Lua虚拟机使用有符号整数
 * 来处理大部分参数，需要确保参数值不会超出有符号整数的表示范围。
 * 
 * 参数范围设计：
 * - MAXARG_Bx: 最大18位无符号值，用于常量表索引
 * - MAXARG_sBx: 最大18位有符号值，用于跳转偏移量
 * - MAXARG_A/B/C: 对应字段的最大无符号值
 * 
 * 有符号参数编码：
 * sBx使用偏移编码(excess-K)，实际值 = 编码值 - MAXARG_sBx
 * 这样可以表示从-MAXARG_sBx到+MAXARG_sBx的范围
 * 
 * 平台兼容性：
 * 在某些平台上，如果Bx字段超过了int类型的位宽限制，
 * 则使用MAX_INT作为安全的最大值
 * 
 * @{
 */
#if SIZE_Bx < LUAI_BITSINT-1
    // 标准情况：Bx字段小于int类型位宽，使用完整范围
    #define MAXARG_Bx       ((1<<SIZE_Bx)-1)    /**< Bx字段最大值：262143 */
    #define MAXARG_sBx      (MAXARG_Bx>>1)      /**< sBx字段最大值：131071 */
#else
    // 特殊情况：Bx字段等于或超过int类型位宽，使用安全限制
    #define MAXARG_Bx       MAX_INT     /**< Bx字段最大值：平台int最大值 */
    #define MAXARG_sBx      MAX_INT     /**< sBx字段最大值：平台int最大值 */
#endif

#define MAXARG_A        ((1<<SIZE_A)-1)     /**< A字段最大值：255 */
#define MAXARG_B        ((1<<SIZE_B)-1)     /**< B字段最大值：511 */
#define MAXARG_C        ((1<<SIZE_C)-1)     /**< C字段最大值：511 */
/** @} */

/**
 * @name 位掩码操作宏
 * @brief 用于指令字段提取和设置的位掩码操作
 * 
 * 详细说明：
 * 这些宏提供了高效的位操作函数，用于从32位指令中提取或设置特定字段。
 * 使用位掩码操作比算术运算更高效，是虚拟机性能优化的关键。
 * 
 * 位掩码原理：
 * - MASK1(n,p): 在位置p处创建n个连续的1位掩码
 * - MASK0(n,p): 在位置p处创建n个连续的0位掩码
 * 
 * 应用场景：
 * - 指令解码：从指令中提取操作码和参数
 * - 指令编码：将操作码和参数组装成指令
 * - 字段修改：在不影响其他字段的情况下修改特定字段
 * 
 * 性能优势：
 * - 位操作比除法和取模运算快数倍
 * - 编译器容易优化位操作为单条机器指令
 * - 避免了分支预测失败的开销
 * 
 * @{
 */
#define MASK1(n,p)      ((~((~(Instruction)0)<<n))<<p)    /**< 创建n位1掩码，起始位置为p */
#define MASK0(n,p)      (~MASK1(n,p))                     /**< 创建n位0掩码，起始位置为p */
/** @} */

#include "llimits.h"

enum OpMode {
    iABC,
    iABx,
    iAsBx
};

#define SIZE_C      9
#define SIZE_B      9
#define SIZE_Bx     (SIZE_C + SIZE_B)
#define SIZE_A      8
#define SIZE_OP     6

#define POS_OP      0
#define POS_A       (POS_OP + SIZE_OP)
#define POS_C       (POS_A + SIZE_A)
#define POS_B       (POS_C + SIZE_C)
#define POS_Bx      POS_C

#if SIZE_Bx < LUAI_BITSINT-1
#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
#define MAXARG_sBx        (MAXARG_Bx>>1)
#else
#define MAXARG_Bx        MAX_INT
#define MAXARG_sBx        MAX_INT
#endif

#define MAXARG_A        ((1<<SIZE_A)-1)
#define MAXARG_B        ((1<<SIZE_B)-1)
#define MAXARG_C        ((1<<SIZE_C)-1)

#define MASK1(n,p)      ((~((~(Instruction)0)<<n))<<p)
#define MASK0(n,p)      (~MASK1(n,p))

/**
 * @name 指令解码和编码宏
 * @brief 用于从指令中提取字段或将字段组装成指令的高效宏
 * 
 * 详细说明：
 * 这些宏是Lua虚拟机的核心操作接口，提供了对32位指令格式的完整访问能力。
 * 每个宏都经过精心优化，使用位操作确保最高的执行效率。
 * 
 * 操作类型：
 * - GET系列：从指令中提取特定字段的值
 * - SET系列：设置指令中特定字段的值，保持其他字段不变
 * - CREATE系列：从各个字段值创建完整的指令
 * 
 * 性能特征：
 * - 所有操作都是O(1)时间复杂度
 * - 使用位操作，编译器可优化为单条机器指令
 * - 避免了条件分支，对CPU缓存友好
 * 
 * 使用模式：
 * 解码时使用GET系列宏提取参数，编码时使用CREATE系列宏生成指令
 * 
 * @{
 */

/**
 * @brief 从指令中提取操作码
 * @param i 32位指令值
 * @return 操作码值(0-63)
 * 
 * 详细说明：
 * 操作码位于指令的最低6位，这种设计使得操作码提取非常高效。
 * 虚拟机执行循环中最频繁的操作就是提取操作码进行指令分派。
 * 
 * 实现原理：
 * 1. 右移POS_OP位（实际为0，不移位）
 * 2. 与SIZE_OP位的掩码进行AND操作
 * 3. 转换为OpCode枚举类型
 * 
 * 性能考虑：
 * 由于操作码在最低位，提取操作可以被编译器优化为最简单的掩码操作
 */
#define GET_OPCODE(i)   (cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))

/**
 * @brief 设置指令的操作码字段
 * @param i 要修改的指令变量
 * @param o 新的操作码值
 * 
 * 详细说明：
 * 在保持其他字段不变的情况下，修改指令的操作码字段。
 * 这个宏主要用于指令优化和代码生成阶段。
 * 
 * 实现原理：
 * 1. 使用MASK0清除原有操作码字段
 * 2. 将新操作码左移到正确位置
 * 3. 与清除后的指令进行OR操作
 * 
 * 安全性：
 * 宏会自动确保新操作码不会影响其他字段的值
 */
#define SET_OPCODE(i,o) ((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
                        ((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))

/**
 * @brief 从指令中提取A参数（目标寄存器）
 * @param i 32位指令值
 * @return A参数值(0-255)
 * 
 * 详细说明：
 * A参数通常表示目标寄存器，是大多数指令的结果存储位置。
 * 在Lua虚拟机中，寄存器实际上是函数调用栈上的槽位。
 * 
 * 使用场景：
 * - 数据移动指令的目标位置
 * - 算术运算指令的结果存储位置
 * - 函数调用指令的返回值存储起始位置
 */
#define GETARG_A(i)     (cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))

/**
 * @brief 设置指令的A参数字段
 * @param i 要修改的指令变量
 * @param u 新的A参数值(0-255)
 * 
 * 详细说明：
 * 在保持其他字段不变的情况下，修改指令的A参数字段。
 * 主要用于指令优化，如寄存器重分配和死代码消除。
 */
#define SETARG_A(i,u)   ((i) = (((i)&MASK0(SIZE_A,POS_A)) | \
                        ((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))

/**
 * @brief 从指令中提取B参数（第一个源操作数）
 * @param i 32位指令值
 * @return B参数值(0-511)
 * 
 * 详细说明：
 * B参数通常是第一个源操作数，可能是寄存器索引、常量索引或立即数。
 * 在iABC格式中，B参数占用9位，提供512个可能的值。
 */
#define GETARG_B(i)     (cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))

/**
 * @brief 设置指令的B参数字段
 * @param i 要修改的指令变量
 * @param b 新的B参数值(0-511)
 */
#define SETARG_B(i,b)   ((i) = (((i)&MASK0(SIZE_B,POS_B)) | \
                        ((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))

/**
 * @brief 从指令中提取C参数（第二个源操作数）
 * @param i 32位指令值
 * @return C参数值(0-511)
 * 
 * 详细说明：
 * C参数通常是第二个源操作数，与B参数类似，可能是寄存器索引、
 * 常量索引或立即数。在二元运算指令中作为右操作数。
 */
#define GETARG_C(i)     (cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))

/**
 * @brief 设置指令的C参数字段
 * @param i 要修改的指令变量
 * @param b 新的C参数值(0-511)
 */
#define SETARG_C(i,b)   ((i) = (((i)&MASK0(SIZE_C,POS_C)) | \
                        ((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))

/**
 * @brief 从指令中提取Bx参数（扩展操作数）
 * @param i 32位指令值
 * @return Bx参数值(0-262143)
 * 
 * 详细说明：
 * Bx参数是B和C参数的组合，提供18位的扩展操作数空间。
 * 主要用于需要大范围索引的指令，如常量加载(LOADK)。
 * 
 * 典型用途：
 * - 常量表索引：访问函数的常量表
 * - 全局变量索引：访问全局变量表
 * - 函数原型索引：访问嵌套函数定义
 */
#define GETARG_Bx(i)    (cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))

/**
 * @brief 设置指令的Bx参数字段
 * @param i 要修改的指令变量
 * @param b 新的Bx参数值(0-262143)
 */
#define SETARG_Bx(i,b)  ((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | \
                        ((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))

/**
 * @brief 从指令中提取sBx参数（有符号扩展操作数）
 * @param i 32位指令值
 * @return sBx参数值(-131071到+131071)
 * 
 * 详细说明：
 * sBx参数是有符号的扩展操作数，使用偏移编码(excess-K)方式表示。
 * 实际值 = 编码值 - MAXARG_sBx，这样可以表示正负跳转偏移。
 * 
 * 主要用途：
 * - 跳转指令：条件跳转和无条件跳转的目标偏移
 * - 循环指令：循环体的跳转偏移
 * - 函数调用：尾调用的跳转偏移
 * 
 * 编码原理：
 * - 0表示最大负值(-MAXARG_sBx)
 * - MAXARG_sBx表示0
 * - 2*MAXARG_sBx表示最大正值(+MAXARG_sBx)
 */
#define GETARG_sBx(i)   (GETARG_Bx(i)-MAXARG_sBx)

/**
 * @brief 设置指令的sBx参数字段
 * @param i 要修改的指令变量
 * @param b 新的sBx参数值(-131071到+131071)
 * 
 * 详细说明：
 * 将有符号值转换为偏移编码后设置到指令中。
 * 转换公式：编码值 = 实际值 + MAXARG_sBx
 */
#define SETARG_sBx(i,b) SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
/** @} */

/**
 * @name 指令创建宏
 * @brief 用于从操作码和参数创建完整指令的宏
 * 
 * 详细说明：
 * 这些宏用于指令生成阶段，将操作码和各个参数组装成32位指令。
 * 编译器使用这些宏生成虚拟机可以执行的指令序列。
 * 
 * @{
 */

/**
 * @brief 创建iABC格式的指令
 * @param o 操作码(0-63)
 * @param a A参数(0-255)
 * @param b B参数(0-511)
 * @param c C参数(0-511)
 * @return 32位指令值
 * 
 * 详细说明：
 * iABC格式是最常用的指令格式，支持三个操作数。
 * 适用于大多数算术运算、逻辑运算和数据移动指令。
 * 
 * 参数布局：
 * - o: 操作码，定义指令的具体操作
 * - a: 目标寄存器，通常是结果存储位置
 * - b: 第一个源操作数
 * - c: 第二个源操作数
 * 
 * 使用示例：
 * - ADD指令: CREATE_ABC(OP_ADD, dest, src1, src2)
 * - MOVE指令: CREATE_ABC(OP_MOVE, dest, src, 0)
 */
#define CREATE_ABC(o,a,b,c) ((cast(Instruction, o)<<POS_OP) \
                            | (cast(Instruction, a)<<POS_A) \
                            | (cast(Instruction, b)<<POS_B) \
                            | (cast(Instruction, c)<<POS_C))

/**
 * @brief 创建iABx格式的指令
 * @param o 操作码(0-63)
 * @param a A参数(0-255)
 * @param bc Bx参数(0-262143)
 * @return 32位指令值
 * 
 * 详细说明：
 * iABx格式用于需要大范围操作数的指令，如常量加载。
 * Bx参数提供18位的索引空间，可以访问大型常量表。
 * 
 * 典型用途：
 * - LOADK指令: CREATE_ABx(OP_LOADK, dest, const_index)
 * - GETGLOBAL指令: CREATE_ABx(OP_GETGLOBAL, dest, name_index)
 */
#define CREATE_ABx(o,a,bc)  ((cast(Instruction, o)<<POS_OP) \
                            | (cast(Instruction, a)<<POS_A) \
                            | (cast(Instruction, bc)<<POS_Bx))
/** @} */

/** @} */

/**
 * @name RK索引操作宏
 * @brief 用于处理寄存器/常量(Register/Konstant)混合索引的宏
 * 
 * 详细说明：
 * Lua虚拟机使用一种巧妙的编码方式来在9位字段中同时表示寄存器索引
 * 和常量索引。这种RK编码大大提高了指令的灵活性和编码密度。
 * 
 * RK编码原理：
 * - 最高位(BITRK)为0：表示寄存器索引，值为0-255
 * - 最高位(BITRK)为1：表示常量索引，实际索引 = 值 & ~BITRK
 * 
 * 设计优势：
 * - 在一个9位字段中编码两种不同类型的操作数
 * - 减少了指令格式的复杂性
 * - 简化了虚拟机的执行逻辑
 * 
 * 性能影响：
 * - 操作数类型判断只需要一次位测试
 * - 索引提取只需要一次位掩码操作
 * - 避免了复杂的操作数解码逻辑
 * 
 * @{
 */

/**
 * @brief RK编码的分界位标志
 * 
 * 详细说明：
 * BITRK是9位B/C字段的最高位(第8位)。当这一位为1时，表示该操作数
 * 是常量索引；为0时表示寄存器索引。
 * 
 * 位模式：
 * - 寄存器：0xxxxxxxx (0-255)
 * - 常量：  1xxxxxxxx (256-511，实际常量索引为0-255)
 */
#define BITRK           (1 << (SIZE_B - 1))     /**< RK编码分界位：第8位 */

/**
 * @brief 测试RK值是否为常量索引
 * @param x RK编码值(0-511)
 * @return 非0表示常量，0表示寄存器
 * 
 * 详细说明：
 * 这是虚拟机执行过程中最频繁的操作之一。每当需要获取操作数值时，
 * 都需要先判断操作数类型，然后选择从寄存器或常量表中取值。
 * 
 * 使用场景：
 * - 算术运算指令：判断操作数来源
 * - 比较指令：判断比较值来源
 * - 表操作指令：判断键值来源
 * 
 * 性能优化：
 * 这个宏被编译为简单的位测试指令，执行时间为O(1)
 */
#define ISK(x)          ((x) & BITRK)

/**
 * @brief 从RK值中提取常量索引
 * @param r RK编码值(256-511)
 * @return 常量表索引(0-255)
 * 
 * 详细说明：
 * 当RK值表示常量时，需要清除最高位以获得实际的常量表索引。
 * 这个操作只在ISK()返回真时才有意义。
 * 
 * 实现原理：
 * 使用位掩码操作清除BITRK位，保留低8位作为常量索引
 * 
 * 使用模式：
 * @code
 * if (ISK(rk_value)) {
 *     int const_index = INDEXK(rk_value);
 *     TValue *constant = &func->k[const_index];
 *     // 使用常量值
 * }
 * @endcode
 */
#define INDEXK(r)       ((int)(r) & ~BITRK)

/**
 * @brief RK编码中常量索引的最大值
 * 
 * 详细说明：
 * 由于RK编码使用9位字段，最高位用作类型标志，实际可用于索引的
 * 只有8位，因此常量表的最大索引为255。
 */
#define MAXINDEXRK      (BITRK - 1)             /**< 常量索引最大值：255 */

/**
 * @brief 将常量索引编码为RK值
 * @param x 常量表索引(0-255)
 * @return RK编码值(256-511)
 * 
 * 详细说明：
 * 在指令生成阶段，编译器使用这个宏将常量索引转换为RK编码。
 * 转换后的值可以直接存储在指令的B或C字段中。
 * 
 * 使用场景：
 * - 编译期：生成引用常量的指令
 * - 优化期：将寄存器操作数替换为常量操作数
 * 
 * 安全性检查：
 * 调用者应确保常量索引不超过MAXINDEXRK
 */
#define RKASK(x)        ((x) | BITRK)

/**
 * @brief 无效寄存器标志
 * 
 * 详细说明：
 * NO_REG用于表示"无寄存器"的概念，通常用于可选参数或特殊情况。
 * 使用A字段的最大值(255)作为无效标志，这个值在正常情况下不会使用。
 * 
 * 使用场景：
 * - 可变参数函数调用
 * - 可选返回值的指令
 * - 临时寄存器分配失败的标记
 */
#define NO_REG          MAXARG_A                /**< 无效寄存器标志：255 */
/** @} */

/** @} */

/**
 * @brief Lua虚拟机操作码枚举：定义所有虚拟机指令的操作码
 * 
 * 详细说明：
 * 这个枚举定义了Lua虚拟机的完整指令集。每个操作码对应一种特定的操作，
 * 虚拟机通过操作码分派执行相应的指令处理函数。Lua虚拟机的设计目标是
 * 简洁而高效，因此指令集被精心设计以覆盖Lua语言的所有操作需求。
 * 
 * 指令分类：
 * 1. 数据移动指令：MOVE, LOADK, LOADBOOL, LOADNIL
 * 2. 变量访问指令：GETUPVAL, GETGLOBAL, GETTABLE
 * 3. 变量赋值指令：SETUPVAL, SETGLOBAL, SETTABLE
 * 4. 表操作指令：NEWTABLE, SETLIST
 * 5. 算术运算指令：ADD, SUB, MUL, DIV, MOD, POW, UNM
 * 6. 逻辑运算指令：NOT, LEN
 * 7. 字符串操作指令：CONCAT
 * 8. 比较跳转指令：EQ, LT, LE, TEST, TESTSET
 * 9. 控制流指令：JMP
 * 10. 函数调用指令：CALL, TAILCALL, RETURN
 * 11. 循环控制指令：FORLOOP, FORPREP, TFORLOOP
 * 12. 特殊指令：SELF, CLOSE, CLOSURE, VARARG
 * 
 * 设计原则：
 * - 指令数量最小化：只包含必需的基本操作
 * - 指令语义清晰：每个指令有明确的操作语义
 * - 执行效率优化：指令设计考虑虚拟机执行效率
 * - 编译器友好：便于编译器生成和优化
 * 
 * 指令格式约定：
 * - A参数：通常是目标寄存器
 * - B参数：通常是第一个源操作数
 * - C参数：通常是第二个源操作数
 * - Bx参数：扩展操作数，用于常量索引
 * - sBx参数：有符号操作数，用于跳转偏移
 * 
 * 注释格式说明：
 * 每个操作码的注释格式为：操作码名 参数格式 操作描述
 * 其中 R(x) 表示寄存器x，Kst(x) 表示常量x，RK(x) 表示寄存器或常量x
 * 
 * @since Lua 5.0
 * @see lvm.c luaV_execute()
 */
typedef enum {
    /**
     * @name 数据移动指令组
     * @brief 用于数据移动和基本值加载的指令
     * @{
     */
    
    /**
     * @brief 寄存器间数据移动：R(A) := R(B)
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=源寄存器, C=未使用
     * 
     * 详细说明：
     * MOVE指令是最基本的数据传输指令，将一个寄存器的值复制到另一个寄存器。
     * 在Lua虚拟机中，这是实现赋值操作和参数传递的基础指令。
     * 
     * 使用场景：
     * - 局部变量赋值：local a = b
     * - 函数参数传递：准备函数调用参数
     * - 表达式求值：保存中间结果
     * - 寄存器重分配：编译器优化过程中的寄存器调整
     * 
     * 性能特点：
     * - 零开销：直接复制值，不涉及类型转换
     * - 内存安全：不改变值的引用计数
     * - 简单快速：虚拟机中执行最快的指令之一
     */
    OP_MOVE,
    
    /**
     * @brief 加载常量：R(A) := Kst(Bx)
     * 
     * 格式：iABx
     * 参数：A=目标寄存器, Bx=常量表索引
     * 
     * 详细说明：
     * LOADK指令从函数的常量表中加载一个常量值到指定寄存器。
     * 常量表包含函数中使用的所有字面常量，如数字、字符串等。
     * 
     * 使用场景：
     * - 字面常量：local x = 42, local s = "hello"
     * - 预计算常量：编译期可计算的表达式结果
     * - 默认值：函数参数默认值
     * 
     * 优化考虑：
     * - 常量折叠：编译器将常量表达式预计算为单个常量
     * - 常量池共享：相同常量在常量表中只存储一份
     * - 类型特化：针对不同类型的常量可能有专门的加载指令
     */
    OP_LOADK,
    
    /**
     * @brief 加载布尔值：R(A) := (Bool)B; if (C) pc++
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=布尔值(0或1), C=跳转标志
     * 
     * 详细说明：
     * LOADBOOL指令加载布尔值并可选择性地跳过下一条指令。
     * 这种设计主要用于实现条件表达式的短路求值。
     * 
     * 使用场景：
     * - 布尔字面量：local flag = true
     * - 条件表达式：a and b or c
     * - 逻辑运算结果：比较操作的结果
     * 
     * 跳转逻辑：
     * - C=0：正常执行，不跳转
     * - C=1：跳过下一条指令
     * 
     * 短路求值优化：
     * 在and/or表达式中，可以根据第一个操作数的值决定是否需要计算第二个操作数
     */
    OP_LOADBOOL,
    
    /**
     * @brief 加载nil值：R(A) := ... := R(B) := nil
     * 
     * 格式：iABC
     * 参数：A=起始寄存器, B=结束寄存器, C=未使用
     * 
     * 详细说明：
     * LOADNIL指令将一个寄存器范围内的所有寄存器设置为nil。
     * 这是一个批量初始化指令，用于高效地初始化多个局部变量。
     * 
     * 使用场景：
     * - 局部变量初始化：local a, b, c
     * - 数组清零：清除表中的连续元素
     * - 函数返回值清理：清除多余的返回值寄存器
     * 
     * 性能优势：
     * - 批量操作：一条指令初始化多个寄存器
     * - 内存效率：避免多条LOADK指令的开销
     * - 缓存友好：连续的内存访问模式
     */
    OP_LOADNIL,
    
    /**
     * @brief 获取上值：R(A) := UpValue[B]
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=上值索引, C=未使用
     * 
     * 详细说明：
     * GETUPVAL指令从闭包的上值数组中获取一个值。上值是被闭包捕获的
     * 外部局部变量，实现了Lua的词法作用域和闭包功能。
     * 
     * 使用场景：
     * - 访问外部变量：function() return outer_var end
     * - 闭包数据共享：多个闭包共享同一个上值
     * - 模块私有变量：模块内部的私有状态
     * 
     * 实现机制：
     * - 上值绑定：函数创建时确定上值绑定关系
     * - 生命周期管理：上值的生命周期独立于创建它的函数
     * - 共享机制：多个闭包可以共享同一个上值
     */
    OP_GETUPVAL,
    /** @} */

    /**
     * @name 全局和表访问指令组
     * @brief 用于访问全局变量和表元素的指令
     * @{
     */
    
    /**
     * @brief 获取全局变量：R(A) := Gbl[Kst(Bx)]
     * 
     * 格式：iABx
     * 参数：A=目标寄存器, Bx=变量名常量索引
     * 
     * 详细说明：
     * GETGLOBAL指令从全局环境表中获取一个全局变量的值。
     * 全局变量名存储在常量表中，通过名称查找获取值。
     * 
     * 使用场景：
     * - 访问全局函数：print, require, type等
     * - 访问全局变量：_G, _VERSION等
     * - 访问模块导出：math.pi, string.len等
     * 
     * 实现细节：
     * - 环境表查找：在当前环境表中按名称查找
     * - 元方法支持：支持__index元方法
     * - 缓存优化：虚拟机可能缓存常用全局变量的访问
     */
    OP_GETGLOBAL,
    
    /**
     * @brief 获取表元素：R(A) := R(B)[RK(C)]
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=表寄存器, C=键(寄存器或常量)
     * 
     * 详细说明：
     * GETTABLE指令从表中获取指定键对应的值。这是Lua中表访问的
     * 基础指令，支持数字索引和字符串键的访问。
     * 
     * 使用场景：
     * - 数组访问：array[index]
     * - 对象属性访问：object.property
     * - 字典查找：dict[key]
     * - 方法访问：object:method()的第一步
     * 
     * 元方法支持：
     * - __index：当键不存在时调用
     * - __newindex：当设置新键时调用（在SETTABLE中）
     * - 元表链：支持递归查找元表
     * 
     * 性能优化：
     * - 快速路径：对于数组部分的整数索引，使用快速访问
     * - 字符串哈希：字符串键使用哈希表查找
     * - 内联缓存：热点访问路径的缓存优化
     */
    OP_GETTABLE,
    /** @} */

    /**
     * @name 变量赋值指令组
     * @brief 用于设置全局变量、上值和表元素的指令
     * @{
     */
    
    /**
     * @brief 设置全局变量：Gbl[Kst(Bx)] := R(A)
     * 
     * 格式：iABx
     * 参数：A=源寄存器, Bx=变量名常量索引
     * 
     * 详细说明：
     * SETGLOBAL指令将寄存器中的值设置到全局环境表的指定变量。
     * 这是实现全局变量赋值的基础指令。
     * 
     * 使用场景：
     * - 创建全局变量：global_var = value
     * - 修改全局变量：existing_global = new_value
     * - 模块导出：设置模块的公共接口
     * 
     * 副作用：
     * - 环境表修改：可能触发__newindex元方法
     * - 全局状态变更：影响程序的全局状态
     * - 模块加载：模块初始化时的全局变量设置
     */
    OP_SETGLOBAL,
    
    /**
     * @brief 设置上值：UpValue[B] := R(A)
     * 
     * 格式：iABC
     * 参数：A=源寄存器, B=上值索引, C=未使用
     * 
     * 详细说明：
     * SETUPVAL指令将寄存器中的值设置到闭包的上值中。
     * 这实现了闭包对外部变量的修改能力。
     * 
     * 使用场景：
     * - 修改捕获的外部变量：outer_var = new_value
     * - 闭包状态更新：更新闭包内部状态
     * - 计数器实现：闭包实现的计数器功能
     * 
     * 生命周期管理：
     * - 上值共享：多个闭包共享的上值会同时更新
     * - 内存管理：上值的引用计数和垃圾回收
     * - 作用域维护：维护词法作用域的正确性
     */
    OP_SETUPVAL,
    
    /**
     * @brief 设置表元素：R(A)[RK(B)] := RK(C)
     * 
     * 格式：iABC
     * 参数：A=表寄存器, B=键(寄存器或常量), C=值(寄存器或常量)
     * 
     * 详细说明：
     * SETTABLE指令设置表中指定键的值。这是Lua中表赋值操作的
     * 基础指令，支持各种类型的键和值。
     * 
     * 使用场景：
     * - 数组赋值：array[index] = value
     * - 对象属性设置：object.property = value
     * - 字典更新：dict[key] = value
     * - 表初始化：构造表的过程
     * 
     * 元方法支持：
     * - __newindex：设置新键时调用
     * - __index：在某些情况下用于查找
     * 
     * 性能考虑：
     * - 表结构调整：可能触发表的重哈希
     * - 内存分配：新键可能导致表扩容
     * - 类型特化：针对数组部分和哈希部分的不同处理
     */
    OP_SETTABLE,
    /** @} */

    /**
     * @brief 创建新表：R(A) := {} (size = B,C)
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=数组部分大小提示, C=哈希部分大小提示
     * 
     * 详细说明：
     * NEWTABLE指令创建一个新的空表，并根据提示预分配适当的内存。
     * B和C参数提供了数组部分和哈希部分的大小提示，有助于性能优化。
     * 
     * 使用场景：
     * - 表字面量：local t = {}
     * - 数组创建：local arr = {1, 2, 3}
     * - 对象创建：local obj = {name = "test"}
     * - 临时表：函数内部使用的临时表
     * 
     * 优化机制：
     * - 预分配：根据提示预分配内存，避免多次重分配
     * - 混合存储：同时支持数组部分和哈希部分
     * - 延迟初始化：某些部分可能延迟到实际使用时初始化
     */
    OP_NEWTABLE,

    /**
     * @brief 方法调用准备：R(A+1) := R(B); R(A) := R(B)[RK(C)]
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=对象寄存器, C=方法名(寄存器或常量)
     * 
     * 详细说明：
     * SELF指令是Lua方法调用语法糖obj:method()的实现基础。
     * 它同时完成方法查找和self参数设置，为方法调用做准备。
     * 
     * 操作步骤：
     * 1. 将对象复制到R(A+1)作为self参数
     * 2. 从对象中获取方法并存储到R(A)
     * 
     * 使用场景：
     * - 方法调用：obj:method(args)
     * - 链式调用：obj:method1():method2()
     * - 面向对象编程：类方法调用
     * 
     * 语法糖展开：
     * obj:method(args) 等价于 obj.method(obj, args)
     */
    OP_SELF,

    /**
     * @name 算术运算指令组
     * @brief 用于基本算术运算的二元和一元指令
     * @{
     */
    
    /**
     * @brief 加法运算：R(A) := RK(B) + RK(C)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=左操作数(RK), C=右操作数(RK)
     * 
     * 详细说明：
     * ADD指令执行两个操作数的加法运算。支持数字相加和字符串连接，
     * 并通过元方法机制支持用户自定义类型的加法操作。
     * 
     * 类型处理：
     * - 数字+数字：标准算术加法
     * - 字符串+数字：数字转换为字符串后连接
     * - 用户类型：调用__add元方法
     * 
     * 性能优化：
     * - 类型检查：快速检查操作数类型
     * - 内联操作：对于数字类型的直接加法
     * - 元方法缓存：缓存元方法查找结果
     */
    OP_ADD,
    
    /**
     * @brief 减法运算：R(A) := RK(B) - RK(C)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=被减数(RK), C=减数(RK)
     * 
     * 详细说明：
     * SUB指令执行减法运算，仅支持数字类型的操作数。
     * 如果操作数不是数字，会尝试转换或调用__sub元方法。
     */
    OP_SUB,
    
    /**
     * @brief 乘法运算：R(A) := RK(B) * RK(C)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=被乘数(RK), C=乘数(RK)
     * 
     * 详细说明：
     * MUL指令执行乘法运算，支持数字类型和通过__mul元方法的
     * 用户定义类型乘法。
     */
    OP_MUL,
    
    /**
     * @brief 除法运算：R(A) := RK(B) / RK(C)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=被除数(RK), C=除数(RK)
     * 
     * 详细说明：
     * DIV指令执行除法运算。需要检查除零错误，并处理浮点除法的
     * 特殊情况（如无穷大、NaN等）。
     * 
     * 错误处理：
     * - 除零检查：检查除数是否为0
     * - 类型转换：将操作数转换为数字
     * - 元方法调用：对于用户类型调用__div元方法
     */
    OP_DIV,
    
    /**
     * @brief 取模运算：R(A) := RK(B) % RK(C)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=被模数(RK), C=模数(RK)
     * 
     * 详细说明：
     * MOD指令执行取模运算，返回两数相除的余数。
     * Lua的取模运算定义确保结果与除数同号。
     * 
     * 数学定义：
     * a % b = a - floor(a/b) * b
     * 这保证了结果与b同号（当b != 0时）
     */
    OP_MOD,
    
    /**
     * @brief 幂运算：R(A) := RK(B) ^ RK(C)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=底数(RK), C=指数(RK)
     * 
     * 详细说明：
     * POW指令执行幂运算（求幂）。使用标准库的pow函数或
     * 优化的整数幂算法来计算结果。
     * 
     * 特殊情况：
     * - 0^0：结果为1（按照Lua的定义）
     * - 负数的非整数幂：可能产生复数（返回NaN）
     * - 无穷大和NaN的处理：遵循IEEE 754标准
     */
    OP_POW,
    
    /**
     * @brief 一元负号：R(A) := -R(B)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=操作数寄存器, C=未使用
     * 
     * 详细说明：
     * UNM指令执行一元负号运算，返回操作数的相反数。
     * 只适用于数字类型，或通过__unm元方法的用户类型。
     * 
     * 实现细节：
     * - 数字类型：直接取负数
     * - 字符串：尝试转换为数字后取负
     * - 用户类型：调用__unm元方法
     */
    OP_UNM,
    
    /**
     * @brief 逻辑非运算：R(A) := not R(B)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=操作数寄存器, C=未使用
     * 
     * 详细说明：
     * NOT指令执行逻辑非运算。在Lua中，只有nil和false被认为是假，
     * 其他所有值（包括0和空字符串）都被认为是真。
     * 
     * 真值表：
     * - nil -> true
     * - false -> true
     * - 其他任何值 -> false
     */
    OP_NOT,
    
    /**
     * @brief 长度运算：R(A) := length of R(B)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=操作数寄存器, C=未使用
     * 
     * 详细说明：
     * LEN指令获取对象的长度。对于不同类型有不同的定义：
     * - 字符串：字节数
     * - 表：序列长度（连续整数索引的最大值）
     * - 用户数据：通过__len元方法定义
     * 
     * 表长度的定义：
     * 表的长度是满足t[n] != nil且t[n+1] == nil的最大正整数n
     * 如果t[1] == nil，则长度为0
     */
    OP_LEN,
    /** @} */

    /**
     * @brief 字符串连接：R(A) := R(B).. ... ..R(C)
     * 
     * 格式：iABC
     * 参数：A=结果寄存器, B=起始寄存器, C=结束寄存器
     * 
     * 详细说明：
     * CONCAT指令将从R(B)到R(C)的所有寄存器中的值连接成一个字符串。
     * 这是实现..操作符的指令，支持多个值的连续连接。
     * 
     * 连接规则：
     * - 字符串直接连接
     * - 数字转换为字符串后连接
     * - nil转换为空字符串
     * - 其他类型通过__tostring或tostring()转换
     * 
     * 性能优化：
     * - 预计算总长度：避免多次内存重分配
     * - 批量连接：一次操作连接多个值
     * - 字符串内化：相同字符串只存储一份
     */
    OP_CONCAT,

    /**
     * @name 控制流指令组
     * @brief 用于程序控制流的跳转和分支指令
     * @{
     */
    
    /**
     * @brief 无条件跳转：pc += sBx
     * 
     * 格式：iAsBx
     * 参数：A=未使用, sBx=跳转偏移量
     * 
     * 详细说明：
     * JMP指令执行无条件跳转，将程序计数器(pc)增加指定的偏移量。
     * 偏移量是有符号数，可以向前或向后跳转。
     * 
     * 使用场景：
     * - 循环结构：for、while、repeat循环的跳转
     * - 条件结构：if-else的跳转
     * - break和continue：循环控制语句
     * - 函数尾部：跳过不需要执行的代码
     * 
     * 跳转计算：
     * 新pc = 当前pc + 1 + sBx
     * 其中+1是因为pc在执行指令后会自动增加1
     */
    OP_JMP,

    /**
     * @name 比较跳转指令组
     * @brief 用于条件判断和比较操作的指令
     * @{
     */
    
    /**
     * @brief 相等比较：if ((RK(B) == RK(C)) ~= A) then pc++
     * 
     * 格式：iABC
     * 参数：A=期望结果(0或1), B=左操作数(RK), C=右操作数(RK)
     * 
     * 详细说明：
     * EQ指令执行相等比较，并根据比较结果和期望值决定是否跳转。
     * 这种设计使得一条指令可以同时处理==和~=两种比较。
     * 
     * 比较规则：
     * - 数字：数值相等
     * - 字符串：内容相等
     * - 表/函数/用户数据：引用相等
     * - nil：只与nil相等
     * - 布尔值：值相等
     * 
     * 跳转逻辑：
     * - A=0：如果相等则跳转（实现~=）
     * - A=1：如果不等则跳转（实现==）
     * 
     * 元方法支持：
     * 如果操作数有__eq元方法，将调用元方法进行比较
     */
    OP_EQ,
    
    /**
     * @brief 小于比较：if ((RK(B) < RK(C)) ~= A) then pc++
     * 
     * 格式：iABC
     * 参数：A=期望结果(0或1), B=左操作数(RK), C=右操作数(RK)
     * 
     * 详细说明：
     * LT指令执行小于比较，支持数字和字符串的比较。
     * 
     * 比较规则：
     * - 数字：数值比较
     * - 字符串：字典序比较
     * - 混合类型：通过__lt元方法或类型错误
     * 
     * 跳转逻辑：
     * - A=0：如果B<C则跳转
     * - A=1：如果B>=C则跳转
     */
    OP_LT,
    
    /**
     * @brief 小于等于比较：if ((RK(B) <= RK(C)) ~= A) then pc++
     * 
     * 格式：iABC
     * 参数：A=期望结果(0或1), B=左操作数(RK), C=右操作数(RK)
     * 
     * 详细说明：
     * LE指令执行小于等于比较，实现<=操作符的功能。
     * 
     * 实现策略：
     * 如果有__le元方法，直接调用；否则尝试使用__lt元方法：
     * a <= b 等价于 not (b < a)
     */
    OP_LE,

    /**
     * @brief 真值测试：if not (R(A) <=> C) then pc++
     * 
     * 格式：iABC
     * 参数：A=测试值寄存器, B=未使用, C=期望真值(0或1)
     * 
     * 详细说明：
     * TEST指令测试寄存器中值的真假性，并根据期望结果决定是否跳转。
     * 在Lua中，只有nil和false是假值，其他都是真值。
     * 
     * 跳转逻辑：
     * - C=0：如果R(A)为假则跳转
     * - C=1：如果R(A)为真则跳转
     * 
     * 符号说明：
     * <=> 表示"等价于"，即测试真假性
     */
    OP_TEST,
    
    /**
     * @brief 条件赋值：if (R(B) <=> C) then R(A) := R(B) else pc++
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=源寄存器, C=期望真值(0或1)
     * 
     * 详细说明：
     * TESTSET指令结合了条件测试和赋值操作，主要用于实现
     * and和or操作符的短路求值。
     * 
     * 操作逻辑：
     * 1. 测试R(B)的真假性
     * 2. 如果符合期望值C，则将R(B)赋值给R(A)
     * 3. 否则跳过下一条指令
     * 
     * 使用场景：
     * - a = b and c：当b为真时，a=c；否则a=b
     * - a = b or c：当b为假时，a=c；否则a=b
     */
    OP_TESTSET,
    /** @} */
    /** @} */

    OP_TESTSET,
    /** @} */
    /** @} */

    /**
     * @name 函数调用指令组
     * @brief 用于函数调用和返回的指令
     * @{
     */
    
    /**
     * @brief 函数调用：R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
     * 
     * 格式：iABC
     * 参数：A=函数寄存器, B=参数个数+1, C=返回值个数+1
     * 
     * 详细说明：
     * CALL指令执行函数调用，支持多参数和多返回值。这是Lua中
     * 函数调用的核心指令，处理参数传递、调用栈管理和返回值处理。
     * 
     * 参数约定：
     * - R(A)：要调用的函数
     * - R(A+1) 到 R(A+B-1)：函数参数
     * - R(A) 到 R(A+C-2)：返回值存储位置
     * 
     * 特殊值：
     * - B=0：参数个数由栈顶决定（用于可变参数）
     * - C=0：返回值个数由函数决定，保留到栈顶
     * 
     * 调用过程：
     * 1. 检查R(A)是否为可调用对象
     * 2. 准备新的调用栈帧
     * 3. 传递参数到新栈帧
     * 4. 执行函数代码
     * 5. 处理返回值
     * 6. 恢复调用栈
     * 
     * 元方法支持：
     * 如果R(A)不是函数，查找__call元方法进行调用
     * 
     * 性能考虑：
     * - 栈帧管理：高效的栈帧分配和释放
     * - 参数传递：最小化内存复制
     * - 尾调用优化：在适当情况下优化为TAILCALL
     */
    OP_CALL,
    
    /**
     * @brief 尾调用：return R(A)(R(A+1), ... ,R(A+B-1))
     * 
     * 格式：iABC
     * 参数：A=函数寄存器, B=参数个数+1, C=未使用
     * 
     * 详细说明：
     * TAILCALL指令执行尾调用优化，直接用被调用函数的返回值
     * 作为当前函数的返回值，避免额外的栈帧开销。
     * 
     * 尾调用条件：
     * - 函数调用是return语句的唯一表达式
     * - 调用结果直接作为返回值
     * - 不需要进行额外的计算
     * 
     * 优化效果：
     * - 节省栈空间：不增加调用栈深度
     * - 提高性能：避免额外的函数返回开销
     * - 避免栈溢出：递归调用不会导致栈溢出
     * 
     * 实现机制：
     * 1. 复用当前栈帧
     * 2. 设置参数到正确位置
     * 3. 直接跳转到目标函数
     * 4. 目标函数返回时直接返回给原调用者
     */
    OP_TAILCALL,
    
    /**
     * @brief 函数返回：return R(A), ... ,R(A+B-2)
     * 
     * 格式：iABC
     * 参数：A=第一个返回值寄存器, B=返回值个数+1, C=未使用
     * 
     * 详细说明：
     * RETURN指令结束当前函数的执行，并返回指定的值。
     * 支持多返回值，这是Lua语言的一个重要特性。
     * 
     * 返回值处理：
     * - B=1：无返回值（return语句无表达式）
     * - B=2：一个返回值R(A)
     * - B>2：多个返回值R(A)到R(A+B-2)
     * - B=0：返回从R(A)到栈顶的所有值
     * 
     * 特殊情况：
     * - B=0时，返回值个数由栈顶位置决定
     * - 用于return func()这种情况，保留func的所有返回值
     * 
     * 执行步骤：
     * 1. 收集返回值到临时位置
     * 2. 清理当前函数的栈帧
     * 3. 恢复调用者的执行环境
     * 4. 将返回值复制到调用者期望的位置
     * 5. 继续执行调用者的代码
     */
    OP_RETURN,
    /** @} */

    /**
     * @name 循环控制指令组
     * @brief 用于实现各种循环结构的指令
     * @{
     */
    
    /**
     * @brief 数值for循环：R(A)+=R(A+2); if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
     * 
     * 格式：iAsBx
     * 参数：A=循环变量寄存器, sBx=循环体跳转偏移
     * 
     * 详细说明：
     * FORLOOP指令实现数值for循环的迭代控制。它更新循环变量，
     * 检查循环条件，并在需要时跳转到循环体开始。
     * 
     * 寄存器约定：
     * - R(A)：当前循环变量值
     * - R(A+1)：循环上限值
     * - R(A+2)：循环步长值
     * - R(A+3)：用户可见的循环变量
     * 
     * 执行步骤：
     * 1. R(A) = R(A) + R(A+2)（更新内部计数器）
     * 2. 检查循环条件：
     *    - 步长>0：检查R(A) <= R(A+1)
     *    - 步长<0：检查R(A) >= R(A+1)
     * 3. 如果条件成立：
     *    - R(A+3) = R(A)（更新用户变量）
     *    - pc += sBx（跳转到循环体）
     * 4. 否则继续执行循环后的代码
     * 
     * 优化特点：
     * - 内部变量与用户变量分离，避免用户修改影响循环控制
     * - 步长符号预判，选择正确的比较操作
     * - 整数优化：对于整数循环使用优化的算法
     */
    OP_FORLOOP,
    
    /**
     * @brief 数值for循环准备：R(A)-=R(A+2); pc+=sBx
     * 
     * 格式：iAsBx
     * 参数：A=循环变量寄存器, sBx=跳转到FORLOOP的偏移
     * 
     * 详细说明：
     * FORPREP指令为数值for循环做准备工作，初始化循环变量并
     * 跳转到FORLOOP指令进行第一次迭代检查。
     * 
     * 准备工作：
     * 1. R(A) = R(A) - R(A+2)（预减步长，因为FORLOOP会先加）
     * 2. 检查初始值、上限值、步长是否为数字
     * 3. 跳转到对应的FORLOOP指令
     * 
     * 错误检查：
     * - 类型检查：确保初始值、上限值、步长都是数字
     * - 步长检查：确保步长不为0
     * - 溢出检查：防止数值溢出
     * 
     * 配合关系：
     * FORPREP总是与FORLOOP成对出现，形成完整的数值循环结构
     */
    OP_FORPREP,

    /**
     * @brief 通用for循环：R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
     * 
     * 格式：iABC
     * 参数：A=迭代器寄存器, B=未使用, C=循环变量个数
     * 
     * 详细说明：
     * TFORLOOP指令实现通用for循环（迭代器循环）的迭代控制。
     * 它调用迭代器函数，获取下一组值，并控制循环的继续或结束。
     * 
     * 寄存器约定：
     * - R(A)：迭代器函数
     * - R(A+1)：不变状态
     * - R(A+2)：控制变量
     * - R(A+3) 到 R(A+2+C)：循环变量
     * 
     * 执行步骤：
     * 1. 调用迭代器：R(A+3),...,R(A+2+C) := R(A)(R(A+1), R(A+2))
     * 2. 检查第一个返回值R(A+3)：
     *    - 如果不是nil：
     *      - R(A+2) = R(A+3)（更新控制变量）
     *      - 继续循环体执行
     *    - 如果是nil：
     *      - pc++（跳过循环体，结束循环）
     * 
     * 使用场景：
     * - for k,v in pairs(t) do ... end
     * - for i,v in ipairs(t) do ... end
     * - 自定义迭代器循环
     * 
     * 迭代器协议：
     * 迭代器函数应该返回控制变量作为第一个值，当迭代结束时返回nil
     */
    OP_TFORLOOP,
    /** @} */

    /**
     * @brief 设置表列表：R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
     * 
     * 格式：iABC
     * 参数：A=表寄存器, B=元素个数, C=批次号
     * 
     * 详细说明：
     * SETLIST指令用于批量设置表的数组部分，主要用于表构造器
     * 中的数组元素初始化。FPF是"Fields Per Flush"的缩写。
     * 
     * 批量设置算法：
     * - 起始索引：(C-1) * LFIELDS_PER_FLUSH + 1
     * - 设置R(A)[起始索引+i-1] = R(A+i)，其中1 <= i <= B
     * 
     * 特殊情况：
     * - B=0：元素个数由栈顶决定
     * - C=0：批次号由下一条指令提供
     * 
     * 使用场景：
     * - 表构造器：{1, 2, 3, 4, 5}
     * - 大型数组初始化：分批处理以避免一次性处理过多元素
     * 
     * 性能优化：
     * - 批量操作：减少单个设置操作的开销
     * - 连续内存访问：利用缓存局部性
     * - 预分配空间：表在构造时预分配足够空间
     * 
     * LFIELDS_PER_FLUSH常量：
     * 定义每批处理的最大元素个数，平衡内存使用和性能
     */
    OP_SETLIST,

    /**
     * @name 特殊指令组
     * @brief 用于特殊操作和高级功能的指令
     * @{
     */
    
    /**
     * @brief 关闭上值：close all variables in the stack up to (>=) R(A)
     * 
     * 格式：iABC
     * 参数：A=边界寄存器, B=未使用, C=未使用
     * 
     * 详细说明：
     * CLOSE指令关闭从R(A)开始到栈顶的所有开放上值（open upvalues）。
     * 这确保了上值的正确生命周期管理和内存一致性。
     * 
     * 上值生命周期：
     * - 开放上值：指向活动栈位置的上值
     * - 关闭上值：将栈上的值复制到上值对象中，断开与栈的联系
     * 
     * 关闭时机：
     * - 函数返回时：关闭所有局部变量的上值
     * - 块结束时：关闭块内声明的局部变量的上值
     * - goto跳转时：关闭跳过的作用域内的上值
     * 
     * 实现原理：
     * 1. 遍历开放上值链表
     * 2. 对于栈位置 >= R(A)的上值：
     *    - 将栈上的值复制到上值对象
     *    - 将上值标记为关闭状态
     *    - 从开放上值链表中移除
     * 
     * 重要性：
     * 正确的上值关闭确保了闭包的语义正确性和内存安全
     */
    OP_CLOSE,
    
    /**
     * @brief 创建闭包：R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
     * 
     * 格式：iABx
     * 参数：A=目标寄存器, Bx=函数原型索引
     * 
     * 详细说明：
     * CLOSURE指令创建一个新的闭包对象，将函数原型与当前环境中的
     * 上值绑定，形成一个可调用的函数对象。
     * 
     * 创建过程：
     * 1. 从常量表中获取函数原型KPROTO[Bx]
     * 2. 创建新的闭包对象
     * 3. 根据原型的上值描述信息绑定上值：
     *    - 本地上值：从当前栈帧获取
     *    - 外部上值：从当前闭包的上值中获取
     * 4. 将闭包存储到R(A)
     * 
     * 上值绑定：
     * 每个上值要么指向当前栈上的局部变量，要么指向外层闭包的上值
     * 绑定信息在函数原型中预先计算好
     * 
     * 使用场景：
     * - 函数定义：local function f() ... end
     * - 匿名函数：function() ... end
     * - 闭包创建：访问外部变量的函数
     * 
     * 性能考虑：
     * - 上值共享：相同的局部变量可以被多个闭包共享
     * - 延迟绑定：只有在实际访问时才创建上值对象
     * - 内存管理：闭包和上值的垃圾回收
     */
    OP_CLOSURE,

    /**
     * @brief 可变参数：R(A), R(A+1), ..., R(A+B-1) = vararg
     * 
     * 格式：iABC
     * 参数：A=目标寄存器, B=参数个数+1, C=未使用
     * 
     * 详细说明：
     * VARARG指令访问函数的可变参数（...），将可变参数复制到
     * 指定的寄存器范围中。
     * 
     * 参数处理：
     * - B=1：不获取任何可变参数
     * - B>1：获取B-1个可变参数
     * - B=0：获取所有可变参数，数量由实际参数决定
     * 
     * 使用场景：
     * - 函数定义：function f(...) ... end
     * - 参数转发：local args = {...}
     * - 选择性访问：local a, b = ...
     * 
     * 实现机制：
     * 1. 从函数的可变参数区域读取参数
     * 2. 复制到目标寄存器范围
     * 3. 不足的位置填充nil
     * 
     * 特殊情况：
     * - 如果函数没有可变参数，所有目标寄存器设为nil
     * - B=0时，设置栈顶以包含所有获取的参数
     * 
     * 性能优化：
     * - 直接访问：避免创建临时表
     * - 按需复制：只复制实际需要的参数
     * - 类型保持：保持参数的原始类型
     */
    OP_VARARG
    /** @} */
} OpCode;

/**
 * @brief 操作码总数：虚拟机支持的指令数量
 * 
 * 详细说明：
 * NUM_OPCODES定义了Lua虚拟机支持的操作码总数。由于OP_VARARG是
 * 最后一个操作码，总数为OP_VARARG的值加1。
 * 
 * 用途：
 * - 数组大小声明：操作码相关数组的大小
 * - 循环边界：遍历所有操作码时的上界
 * - 有效性检查：验证操作码是否在有效范围内
 * 
 * 限制：
 * 由于操作码字段只有6位，最多支持64个不同的操作码
 */
#define NUM_OPCODES     (cast(int, OP_VARARG) + 1)

/**
 * @brief 操作参数掩码枚举：定义指令参数的类型和用途
 * 
 * 详细说明：
 * OpArgMask枚举定义了指令参数的不同类型，用于描述每个操作码的
 * 参数格式和语义。这些信息存储在luaP_opmodes数组中，供虚拟机
 * 和调试工具使用。
 * 
 * 参数类型：
 * - OpArgN：参数未使用
 * - OpArgU：参数已使用，但类型不确定
 * - OpArgR：参数是寄存器索引或跳转偏移
 * - OpArgK：参数是常量索引或寄存器/常量混合(RK)
 * 
 * 应用场景：
 * - 指令解析：确定如何解释指令参数
 * - 代码生成：验证指令格式的正确性
 * - 调试工具：格式化指令的可读表示
 * - 静态分析：分析代码的数据流和控制流
 * 
 * @since Lua 5.0
 * @see luaP_opmodes
 */
enum OpArgMask {
    OpArgN,     /**< 参数未使用：该参数位置没有实际意义 */
    OpArgU,     /**< 参数已使用：参数有意义但类型不确定 */
    OpArgR,     /**< 寄存器或偏移：寄存器索引或跳转偏移量 */
    OpArgK      /**< 常量或RK：常量索引或寄存器/常量混合编码 */
};

/**
 * @brief 操作码属性表：存储每个操作码的参数格式和属性信息
 * 
 * 详细说明：
 * luaP_opmodes是一个字节数组，每个元素对应一个操作码，使用位掩码
 * 编码该操作码的各种属性。这个设计使得属性查询非常高效。
 * 
 * 位域格式（8位）：
 * - 位 0-1：操作模式（OpMode）
 * - 位 2-3：C参数模式（OpArgMask）
 * - 位 4-5：B参数模式（OpArgMask）
 * - 位 6：A参数设置标志（指令是否设置A寄存器）
 * - 位 7：测试标志（指令是否为测试指令）
 * 
 * 使用方式：
 * - 编译期：验证指令格式
 * - 运行期：优化指令执行
 * - 调试期：格式化指令显示
 * 
 * 数据来源：
 * 这个数组在lopcodes.c中定义，与OpCode枚举保持同步
 */
LUAI_DATA const lu_byte luaP_opmodes[NUM_OPCODES];

/**
 * @name 操作码属性查询宏
 * @brief 用于查询指令属性的高效宏
 * 
 * 详细说明：
 * 这些宏从luaP_opmodes数组中提取特定的属性信息。使用位操作
 * 确保查询的高效性，这些操作在虚拟机执行过程中被频繁调用。
 * 
 * @{
 */

/**
 * @brief 获取操作码的指令格式
 * @param m 操作码值
 * @return OpMode枚举值（iABC、iABx或iAsBx）
 * 
 * 详细说明：
 * 提取指令的基本格式信息，用于确定如何解析指令的参数字段。
 */
#define getOpMode(m)    (cast(enum OpMode, luaP_opmodes[m] & 3))

/**
 * @brief 获取B参数的类型
 * @param m 操作码值
 * @return OpArgMask枚举值
 * 
 * 详细说明：
 * 提取B参数的类型信息，用于确定如何解释B字段的值。
 */
#define getBMode(m)     (cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))

/**
 * @brief 获取C参数的类型
 * @param m 操作码值
 * @return OpArgMask枚举值
 * 
 * 详细说明：
 * 提取C参数的类型信息，用于确定如何解释C字段的值。
 */
#define getCMode(m)     (cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))

/**
 * @brief 测试指令是否设置A寄存器
 * @param m 操作码值
 * @return 非零值表示指令会修改A寄存器的值
 * 
 * 详细说明：
 * 检查指令是否会向A寄存器写入值。这个信息对于寄存器分配
 * 和数据流分析很重要。
 * 
 * 用途：
 * - 寄存器生命周期分析
 * - 死代码消除优化
 * - 调试信息生成
 */
#define testAMode(m)    (luaP_opmodes[m] & (1 << 6))

/**
 * @brief 测试指令是否为测试指令
 * @param m 操作码值
 * @return 非零值表示指令是测试指令（会跳过下一条指令）
 * 
 * 详细说明：
 * 检查指令是否为测试指令。测试指令会根据条件决定是否跳过
 * 下一条指令，这种模式用于实现条件跳转。
 * 
 * 测试指令列表：
 * - EQ, LT, LE：比较指令
 * - TEST, TESTSET：逻辑测试指令
 * 
 * 控制流影响：
 * 测试指令可能改变执行流程，对控制流分析和优化很重要
 */
#define testTMode(m)    (luaP_opmodes[m] & (1 << 7))
/** @} */

/**
 * @brief 操作码名称表：存储所有操作码的字符串名称
 * 
 * 详细说明：
 * luaP_opnames是一个字符串数组，包含所有操作码的名称。
 * 主要用于调试、错误报告和代码反汇编。
 * 
 * 用途：
 * - 调试输出：显示可读的指令名称
 * - 错误报告：在错误信息中包含指令名称
 * - 反汇编器：将字节码转换为可读文本
 * - 性能分析：统计各指令的执行频率
 * 
 * 数组大小：
 * 大小为NUM_OPCODES+1，最后一个元素为NULL，用作结束标记
 */
LUAI_DATA const char *const luaP_opnames[NUM_OPCODES+1];

/**
 * @brief SETLIST指令的批处理大小
 * 
 * 详细说明：
 * LFIELDS_PER_FLUSH定义了SETLIST指令每批处理的表元素数量。
 * 这个值平衡了内存使用和性能，避免一次处理过多元素导致的
 * 栈溢出，同时保持批量操作的效率。
 * 
 * 影响因素：
 * - 栈大小限制：避免超出虚拟机栈的容量
 * - 缓存性能：批量操作的缓存局部性
 * - 编译复杂度：影响表构造器的编译策略
 * 
 * 使用场景：
 * - 大型数组字面量：{1,2,3,...,100}
 * - 表构造器优化：分批初始化表元素
 * - 内存分配策略：预分配表的数组部分
 * 
 * 历史值：
 * 50是一个经过测试的值，在各种场景下都有良好的性能表现
 */
#define LFIELDS_PER_FLUSH   50

#endif
